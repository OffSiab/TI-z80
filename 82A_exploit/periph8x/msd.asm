;Mass storage device routines
;TODO: re-do this whole file and how sector reads/writes happen

 include "settings.inc"
 include "ti83plus.inc"
 include "equates.inc" 
 SEGMENT Main
 GLOBALS ON

 EXTERN DispHexHL,debugStep,IPutC,LDIRtoExtraRAMPage,cphlde,currentRAMSector,currentFlashSector
 EXTERN RAMSectorOffset,FlashSectorOffset,LDIRtoDirEntries,IPutS,IPutS11,DispHexA,curVATptr

RAMStartingCluster	EQU	tempSwapArea		;2
flashStartingCluster	EQU	tempSwapArea+2	;2
currentCluster	EQU	tempSwapArea+4	;2
currentOffset		EQU	tempSwapArea+6	;1
tempWord             EQU    tempSwapArea+7       ;2

;Mass Storage Device
MSDdeviceDescriptor:
	DB 12h		;size of descriptor
	DB 01h		;device descriptor type
	DW 0200h	;USB version
	DB 00h ;08h		;bDeviceClass
	DB 00h ;06h		;bDeviceSubClass
	DB 00h ;50h		;bDeviceProtocol
	DB 40h		;bMaxPacketSize0
	DW 0781h ;0451h	;wVendorID
	DW 5150h ;2008h	;wProductID
	DW 0010h ;0100h	;device release number
	DB 01h		;manufacturer string index
	DB 02h		;product string index
	DB 03h ;00h		;serial number string index
	DB 01h		;bNumConfigurations
MSDconfigDescriptor:
       DB 09h		;size of descriptor
	DB 02h		;config descriptor type
	DW 32		;total length of all descriptors
	DB 01h		;number of interfaces
	DB 01h		;configuration number
	DB 00h		;configuration string index
	DB 11000000b	;bmAttributes
	DB 0          ;bMaxPower (0mA)
;Interface descriptor
       DB 09h        ;size of descriptor
       DB 04h        ;interface descriptor type
       DB 00h        ;interface number
       DB 00h        ;bAlternateSetting
       DB 02h        ;bNumEndpoints
       DB 08h        ;bInterfaceClass
       DB 06h        ;bInterfaceSubClass
       DB 50h        ;bInterfaceProtocol
       DB 00h        ;interface string index
;Endpoint descriptor (in)
       DB 07h        ;size of descriptor
       DB 05h        ;endpoint descriptor type
       DB 10000001b  ;bEndpointAddress
       DB 02h        ;bulk endpoint
       DW 0040h      ;wMaxPacketSize
       DB 00h        ;bInterval
;Endpoint descriptor (out)
       DB 07h        ;size of descriptor
       DB 05h        ;endpoint descriptor type
       DB 00000010b  ;bEndpointAddress
       DB 02h        ;bulk endpoint
       DW 0040h      ;wMaxPacketSize
       DB 00h        ;bInterval

handleReadSectorEvent:
;The host has requested a logical block of data from us. Size of block is in BC.
;Number of logical blocks is in A.
;The starting LBA for this block is DEHL.
;Goal:
;      Find/parse/generate this data and place it at sectorBuffer in zone 1.
;             Three possibilities:
;                    1. This was an attempt at retrieving the FAT table.
;                         Send it from pages 85h\84h.
;                    2. This was an attempt at retrieving a directory structure.
;                         Either send it blindly or generate it to send.
;                    3. This was an attempt at retrieving variable data.
;                         Find out which variable this is, generate, and send it.
;       push af                                          ;*** TESTING
;       push hl                                          ;*** TESTING
;       push bc                                          ;*** TESTING
;       pop hl                                           ;*** TESTING
;       call DispHexHL                                   ;*** TESTING
;       ld a,5                                           ;*** TESTING
;       call IPutC                                       ;*** TESTING
;       pop hl                                           ;*** TESTING
;       ex de,hl                                         ;*** TESTING
;       call DispHexHL                                   ;*** TESTING
;       ex de,hl                                         ;*** TESTING
;       call DispHexHL                                   ;*** TESTING
;       pop af                                           ;*** TESTING
       ;Retrieve this sector, and then all the subsequent ones and store them in the buffer
       ld b,a
       ld ix,sectorBuffer
$$:    push de
       push hl
       push bc
        push de
         push ix
          call RetrieveSector         ;copy sector DEHL to tempSectorBuffer
         pop de
         ld hl,tempSectorBuffer
         ld bc,512
         push bc
          call LDIRtoExtraRAMPage
         pop bc
         push de
         pop ix
        pop de
       pop bc
       pop hl
       pop de
       inc hl
       ld a,h
       or l
       jr nz,doSectorLoop
       inc de
doSectorLoop:
       djnz $B
       ret

RetrieveSector:
;Retrieve logical sector DEHL to tempSectorBuffer.
;Input:       DEHL => requested sector
;Output:      tempSectorBuffer => sector data
;Currently, this routine is hard-coded to return certain sectors.
       ld a,d
       or e
       jr nz,fileDataSector
       push hl
       ld bc,rootDirectoryLBA
       or a
       sbc hl,bc
       pop hl
       jr nz,$F
rootDirectoryEntry:
       ;Root directory entry
       ld hl,tempSectorBuffer
       ld (hl),0
       ld de,tempSectorBuffer+1
       ld bc,511
       ldir
       ld hl,rootDirectoryContents
       ld de,tempSectorBuffer
       ld bc,rootDirectoryContentsEnd-rootDirectoryContents
       ldir
       ret
$$:    ld a,h
       or l
       jr z,isBootSector
       ld de,rootDirectoryLBA
       call cphlde
       jr c,isFATSector
dataSector:
       ;Is this a directory entry sector?
       push hl
       ld bc,dataStartLBA
       or a
       sbc hl,bc
       pop hl
       jr nc,fileDataSector
ReadFATClusterFromRAM:
;Inputs:      HL: cluster containing directory entry data
;Outputs:     tempSectorBuffer contains cluster data
       or a
       ld de,003Fh          ;*** HACK: yeah...this is the boot sector + 20h sectors for FAT + 20h sectors for root entries - 2 because of FAT root directory screwiness
       sbc hl,de
       di
       ld a,06h
       bit 5,l
       jr nz,$F
       inc a
$$:    out (5),a
       add hl,hl ;*2
       add hl,hl ;*4
       add hl,hl ;*8
       add hl,hl ;*16
       add hl,hl ;*32
       add hl,hl ;*64
       add hl,hl ;*128
       add hl,hl ;*256
       add hl,hl ;*512
       ld de,0C000h
       add hl,de
       ld de,tempSectorBuffer
       ld bc,512
       ldir
       xor a
       out (5),a
       ret
fileDataSector:
       ld hl,tempSectorBuffer
       ld (hl),0
       ld de,tempSectorBuffer+1
       ld bc,511
       ldir
       ret
isBootSector:
       ;Boot sector
       ld hl,bootSector
       ld de,tempSectorBuffer
       ld bc,512
       ldir
       ret
isFATSector:
       ;TODO: stop this from using page 84h
       ;Get the FAT sector from pages 85h\84h
       dec hl
       add hl,hl ;*2
       add hl,hl ;*4
       add hl,hl ;*8
       add hl,hl ;*16
       add hl,hl ;*32
       add hl,hl ;*64
       add hl,hl ;*128
       add hl,hl ;*256
       add hl,hl ;*512
       ld de,8000h
       add hl,de
       ld de,tempSectorBuffer
       ld bc,512
$$:    push bc
       ld a,85h
       out (7),a
       ld a,04h
       out (5),a
       ld b,(hl)
       ld a,81h
       out (7),a
       xor a
       out (5),a
       ld a,b
       ld (de),a
       inc hl
       inc de
       pop bc
       dec bc
       ld a,b
       or c
       jr nz,$B
       ret
rootDirectoryContents:
       DB "RAM     ","   "
       DB 10h             ;subdirectory
       DB 00h             ;reserved
       DB 00h             ;creation time, fine resolution
       DB 00h,00h         ;creation time
       DB 00h,00h         ;creation date
       DB 00h,00h         ;last accessed date
       DB 00h,00h         ;zero?
       DB 00h,00h         ;last modified time
       DB 00h,00h         ;last modified date
       DB 02h,00h         ;first cluster
       DB 00h,00h,00h,00h ;file size (zero for subdirectory)
       DB 0E5h,"LASH   ","   "
       DB 10h             ;subdirectory
       DB 00h             ;reserved
       DB 00h             ;creation time, fine resolution
       DB 00h,00h         ;creation time
       DB 00h,00h         ;creation date
       DB 00h,00h         ;last accessed date
       DB 00h,00h         ;zero?
       DB 00h,00h         ;last modified time
       DB 00h,00h         ;last modified date
       DB 03h,00h         ;first cluster ;TODO: this should probably dynamically change or something
       DB 00h,00h,00h,00h ;file size (zero for subdirectory)
rootDirectoryContentsEnd:

handleWriteSectorEvent:
;We've just been given a logical block of data of size BC to sectorBuffer in zone 1.
;The starting LBA for this block is DEHL.
;Number of logical blocks is A.
;Do not mess with interrupts or asm_ram.
;Goal:
;      Find out where each sector of this block is supposed to go.
;             Three possibilities:
;                    1. This was an attempt at changing the FAT table.
;                         Write it to pages 85h\84h, but scan for changes.
;                    2. This was an attempt at changing a directory structure.
;                         Either accept it blindly or parse it for changes (complicated).
;                    3. This was an attempt at changing variable data.
;                         Find out which variable this is and modify accordingly.
;      Move this data to where it needs to be.
       push hl                                          ;*** TESTING
       push bc                                          ;*** TESTING
       pop hl                                           ;*** TESTING
       call DispHexHL                                   ;*** TESTING
       ld a,5                                           ;*** TESTING
       call IPutC                                       ;*** TESTING
       pop hl                                           ;*** TESTING
       ex de,hl                                         ;*** TESTING
       call DispHexHL                                   ;*** TESTING
       ex de,hl                                         ;*** TESTING
       call DispHexHL                                   ;*** TESTING
       or a
       ret

CalculateMSDVariableData:
;Fills extra RAM pages with data from calculator variables (so they're visible as files)
;Inputs:      None
;Outputs:     RAM pages filled
;             Carry flag set if failure
;This is called once on init...probably needs to change for it to be called elsewhere (which shouldn't happen (or should it?))
       ;Zero out directory entry area
       di
       ld a,87h
       out (7),a
       ld a,06h
       out (5),a
       ld hl,8000h
       ld (hl),0
       ld de,8001h
       ld bc,8000h-1
       ldir
       ld a,81h
       out (7),a
       xor a
       out (5),a
       inc bc
       inc bc
       ld (RAMStartingCluster),bc
       ld (currentCluster),bc
       ;Loop through all variables and add to directory entry RAM pages
       ld hl,symTable
       ld (curVATptr),hl
       ld hl,8040h
       ld (iMathPtr5),hl
       ld bc,512-40h
       B_CALL MemClear
       ;Write . and .. entries
       ld hl,parentEntries
       ld de,8000h
       ld bc,64
       ldir
       ld b,14
       jr $F
storeNamesLoop:
       ld hl,8000h
       ld (iMathPtr5),hl
       ld bc,512
       B_CALL MemClear
       ld b,16
$$:    push bc
       call getNextVariable
       pop bc
       jr c,$F
       push bc
       ;Get directory entry information for variable in OP1
       call GetASCIIFileName
       ;Build directory entry for this variable
       ld hl,OP2
       ld de,(iMathPtr5)
       ld bc,11
       ldir
       inc de ;file attributes
       inc de ;reserved
       inc de ;create time, fine resolution
       ex de,hl
       ld (hl),0FFh ;create time (1)
       inc hl
       ld (hl),0FFh ;create time (2)
       inc hl
       ld (hl),0FFh ;create date (1)
       inc hl
       ld (hl),0FFh ;create date (2)
       inc hl
       inc hl ;last access date (1)
       inc hl ;last access date (2)
       inc hl ;EA index (1)
       inc hl ;EA index (2)
       ld (hl),0FFh ;last modified time (1)
       inc hl
       ld (hl),0FFh ;last modified time (2)
       inc hl
       ld (hl),0FFh ;last modified date (1)
       inc hl
       ld (hl),0FFh ;last modified date (2)
       inc hl
       push hl
       ;Allocate new cluster for this and get it in BC
       ld bc,0
       pop hl
       ld (hl),c
       inc hl
       ld (hl),b
       inc hl
       push hl
       ;Get variable's file size in BC
       call GetVariableFileSize
       pop hl
       ld (hl),c
       inc hl
       ld (hl),b
       inc hl
       inc hl ;file size high word (1)
       inc hl ;file size high word (2)
       ld (iMathPtr5),hl
       pop bc
       djnz $B
       xor a
$$:    push af
       ;Write this cluster to memory
       ld hl,8000h
       ld bc,(currentCluster)
       call WriteFATClusterToRAM
       ld hl,(currentCluster)
       ld bc,0FFFFh
       call WriteFATEntry
       pop af
       jr c,$F
       ;Advance to next cluster
       ld bc,(currentCluster)
       push bc
       pop hl
       inc bc
       ld (currentCluster),bc
       ;ld bc,0FFFFh
       call WriteFATEntry
       ld hl,(currentCluster)
       ld bc,0FFFFh
       call WriteFATEntry
       ;If we still have more variables, keep on going
       ret
       jr storeNamesLoop
$$:    xor a
       ret
parentEntries:
       DB ".          ",0,0,0,0,0
       DB 0,0,0,0,0,0,0,0,0,0,02h,0,0,0,0,0
       DB "..         ",0,0,0,0,0
       DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

GetVariableFileSize:
       B_CALL ChkFindSym
       ld bc,0
       ret c
       ex de,hl
       ld e,(hl)
       inc hl
       ld d,(hl)
       ld hl,74
       add hl,de
       push hl
       pop bc
       ret

WriteFATEntry:
;Writes cluster number to specified location in FAT and reverse FAT tables.
;Inputs:      HL: cluster location in FAT to write number
;             BC: number to write
       push hl
       push bc
       add hl,hl
       ld de,8000h
       add hl,de
       ld a,85h
       out (7),a
       ld (hl),c
       inc hl
       ld (hl),b
       ld a,84h
       out (7),a
       ;Write reverse FAT entry
       ld hl,0FFFFh
       or a
       sbc hl,bc
       jr z,$F ;don't do anything if we're writing end-of-file
       pop hl
       pop bc
       add hl,hl
       add hl,de
       ld (hl),c
       inc hl
       ld (hl),b
       push bc
       push hl
$$:    pop bc
       pop hl
       ld a,81h
       out (7),a
       ret

WriteFATClusterToRAM:
;Writes directory entry cluster to RAM
;Inputs:      HL => Directory entry cluster data
;             BC: cluster to write to
       ld (tempWord),hl
       di
       ld a,06h
       bit 5,c
       jr nz,$F
       inc a
$$:    out (5),a
       push bc
       pop hl
       add hl,hl ;*2
       add hl,hl ;*4
       add hl,hl ;*8
       add hl,hl ;*16
       add hl,hl ;*32
       add hl,hl ;*64
       add hl,hl ;*128
       add hl,hl ;*256
       add hl,hl ;*512
       ld de,0C000h
       add hl,de
       ex de,hl
       ld hl,(tempWord)
       ld bc,512
       ldir
       xor a
       out (5),a
       ret

GetASCIIFileName:
;Converts a variable name to DOS 8.3 file name format
;Inputs:      OP1 contains variable name and type
;Outputs:     OP2 contains DOS 8.3 file name (including extension)
       push hl
       ld hl,OP1+1
       ld de,OP2
       ld b,8
gafnLoop:
       ld a,(hl)
       cp 'a'
       jp m,$F
       cp 'A'
       jp p,$F
       sub 'a'
       add a,'A' ;ugly, I know, I'm lazy
$$:    or a
       jr z,gafnLoopDone
       ld (de),a
       inc hl
       inc de
       djnz gafnLoop
       jr $F
gafnLoopDone:
       ld a,' '
spaceLoop:
       ld (de),a
       inc de
       djnz spaceLoop
$$:    ld a,'8'
       ld (de),a
       inc de
       ld a,'X'
       ld (de),a
       inc de
       ld a,(OP1)
       call getTypeCharacter
       ld (de),a
       inc de
       xor a
       ld (de),a
       pop hl
       ret
getTypeCharacter:
       ld c,a
       ld b,0
       ld hl,typeCharacterTable
       add hl,bc
       ld a,(hl)
       ret
typeCharacterTable:
       DB 'N' ;REAL
       DB 'L' ;list
       DB 'M' ;matrix
       DB 'Y' ;Y-var
       DB 'S' ;string
       DB 'P' ;program
       DB 'P' ;protected program
       DB 'I' ;picture
       DB 'D' ;GDB
       DB 0
       DB 0
       DB 'W' ;Window settings
       DB 'C' ;Complex number
       DB 'L' ;complex list
       DB 0
       DB 'W' ;Window settings
       DB 'Z' ;Saved Window settings
       DB 'T' ;Table Setup
       DB 0
       DB 'B' ;Backup
       DB 'K' ;Flash application
       DB 'V' ;appvar
       DB 0
       DB 'G' ;group

getNextVariable:
       call getNext
       ret c
       B_CALL FindSym
       ld a,b
       or a
       jr nz,getNextVariable
	ret
getNext:
       ld hl,(curVATptr)
       ld bc,(pTemp)
       or a
       sbc hl,bc
       ret c
       scf
       ret z
       add hl,bc
       ld d,0
       ld a,(hl)
       dec hl
       ld c,(hl)
       inc hl
       and 1Fh
       ld (OP1),a
       ld e,6
       sbc hl,de
       ld e,3
       push af
       cp AppVarObj
       jr z,$F
       cp ProgObj
       jr z,$F
       cp ProtProgObj
       jr z,$F
       cp TempProgObj
       jr z,$F
       cp 17h
       jr z,$F
       dec hl
       ld a,(hl)
       inc hl
       cp tVarLst
       jr nz,skipAhead
$$:    ld e,(hl)
       inc e
skipAhead:
       or a
       sbc hl,de
       push hl
       add hl,de
       dec e
       ld b,e
       ld de,OP1+1
       dec hl
$$:    ld a,(hl)
       ld (de),a
       dec hl
       inc de
       djnz $B
       ld a,(OP1+1)
       xor a
       ld (de),a
       pop hl
       ld (curVATptr),hl
       pop af
       or a
       ret

bootSector:
       ;FAT16 boot sector
       DB 0EBh, 3Ch, 90h, 4Dh, 53h, 44h, 4Fh, 53h, 35h, 2Eh, 30h, 00h, 02h, 01h, 01h, 00h

;       DB  01h, 00h, 02h, 00h, 0Ch,0F8h, 3Eh, 00h, 3Fh, 00h,0FFh, 00h, 3Fh, 00h, 00h, 00h
       DB  01h, 00h, 02h, 00h, 0Ch,0F8h, 20h, 00h, 3Fh, 00h,0FFh, 00h, 3Fh, 00h, 00h, 00h

       DB  00h, 00h, 00h, 00h, 80h, 00h, 29h,0DAh, 7Bh,0A8h, 2Ch, 4Eh, 4Fh, 20h, 4Eh, 41h
       DB  4Dh, 45h, 20h, 20h, 20h, 20h, 46h, 41h, 54h, 31h, 36h, 20h, 20h, 20h, 33h,0C9h
       DB  8Eh,0D1h,0BCh,0F0h, 7Bh, 8Eh,0D9h,0B8h, 00h, 20h, 8Eh,0C0h,0FCh,0BDh, 00h, 7Ch
       DB  38h, 4Eh, 24h, 7Dh, 24h, 8Bh,0C1h, 99h,0E8h, 3Ch, 01h, 72h, 1Ch, 83h,0EBh, 3Ah
       DB  66h, 0A1h,1Ch, 7Ch, 26h, 66h, 3Bh, 07h, 26h, 8Ah, 57h,0FCh, 75h, 06h, 80h,0CAh
       DB  02h, 88h, 56h, 02h, 80h,0C3h, 10h, 73h,0EBh, 33h,0C9h, 8Ah, 46h, 10h, 98h,0F7h
       DB  66h, 16h, 03h, 46h, 1Ch, 13h, 56h, 1Eh, 03h, 46h, 0Eh, 13h,0D1h, 8Bh, 76h, 11h
       DB  60h, 89h, 46h,0FCh, 89h, 56h,0FEh,0B8h, 20h, 00h,0F7h,0E6h, 8Bh, 5Eh, 0Bh, 03h
       DB 0C3h, 48h,0F7h,0F3h, 01h, 46h,0FCh, 11h, 4Eh,0FEh, 61h,0BFh, 00h, 00h,0E8h,0E6h
       DB  00h, 72h, 39h, 26h, 38h, 2Dh, 74h, 17h, 60h,0B1h, 0Bh,0BEh,0A1h, 7Dh,0F3h,0A6h
       DB  61h, 74h, 32h, 4Eh, 74h, 09h, 83h,0C7h, 20h, 3Bh,0FBh, 72h,0E6h,0EBh,0DCh,0A0h
       DB 0FBh, 7Dh,0B4h, 7Dh, 8Bh,0F0h,0ACh, 98h, 40h, 74h, 0Ch, 48h, 74h, 13h,0B4h, 0Eh
       DB 0BBh, 07h, 00h,0CDh, 10h,0EBh,0EFh,0A0h,0FDh, 7Dh,0EBh,0E6h,0A0h,0FCh, 7Dh,0EBh
       DB 0E1h,0CDh, 16h,0CDh, 19h, 26h, 8Bh, 55h, 1Ah, 52h,0B0h, 01h,0BBh, 00h, 00h,0E8h
       DB  3Bh, 00h, 72h,0E8h, 5Bh, 8Ah, 56h, 24h,0BEh, 0Bh, 7Ch, 8Bh,0FCh,0C7h, 46h,0F0h
       DB  3Dh, 7Dh,0C7h, 46h,0F4h, 29h, 7Dh, 8Ch,0D9h, 89h, 4Eh,0F2h, 89h, 4Eh,0F6h,0C6h
       DB  06h, 96h, 7Dh,0CBh,0EAh, 03h, 00h, 00h, 20h, 0Fh,0B6h,0C8h, 66h, 8Bh, 46h,0F8h
       DB  66h, 03h, 46h, 1Ch, 66h, 8Bh,0D0h, 66h,0C1h,0EAh, 10h,0EBh, 5Eh, 0Fh,0B6h,0C8h
       DB  4Ah, 4Ah, 8Ah, 46h, 0Dh, 32h,0E4h,0F7h,0E2h, 03h, 46h,0FCh, 13h, 56h,0FEh,0EBh
       DB  4Ah, 52h, 50h, 06h, 53h, 6Ah, 01h, 6Ah, 10h, 91h, 8Bh, 46h, 18h, 96h, 92h, 33h
       DB 0D2h,0F7h,0F6h, 91h,0F7h,0F6h, 42h, 87h,0CAh,0F7h, 76h, 1Ah, 8Ah,0F2h, 8Ah,0E8h
       DB 0C0h,0CCh, 02h, 0Ah,0CCh,0B8h, 01h, 02h, 80h, 7Eh, 02h, 0Eh, 75h, 04h,0B4h, 42h
       DB  8Bh,0F4h, 8Ah, 56h, 24h,0CDh, 13h, 61h, 61h, 72h, 0Bh, 40h, 75h, 01h, 42h, 03h
       DB  5Eh, 0Bh, 49h, 75h, 06h,0F8h,0C3h, 41h,0BBh, 00h, 00h, 60h, 66h, 6Ah, 00h,0EBh
       DB 0B0h, 4Eh, 54h, 4Ch, 44h, 52h, 20h, 20h, 20h, 20h, 20h, 20h, 0Dh, 0Ah, 52h, 65h
       DB  6Dh, 6Fh, 76h, 65h, 20h, 64h, 69h, 73h, 6Bh, 73h, 20h, 6Fh, 72h, 20h, 6Fh, 74h
       DB  68h, 65h, 72h, 20h, 6Dh, 65h, 64h, 69h, 61h, 2Eh,0FFh, 0Dh, 0Ah, 44h, 69h, 73h
       DB  6Bh, 20h, 65h, 72h, 72h, 6Fh, 72h,0FFh, 0Dh, 0Ah, 50h, 72h, 65h, 73h, 73h, 20h
       DB  61h, 6Eh, 79h, 20h, 6Bh, 65h, 79h, 20h, 74h, 6Fh, 20h, 72h, 65h, 73h, 74h, 61h
       DB  72h, 74h, 0Dh, 0Ah, 00h, 00h, 00h, 00h, 00h, 00h, 00h,0ACh,0CBh,0D8h, 55h,0AAh

	COMMENT ~
	;Boot sector for BIOS boot testing
       DB 0EBh, 58h, 90h, 56h, 6Ch, 61h, 44h, 4Fh
       DB 53h, 20h, 20h, 00h, 02h, 04h, 22h, 00h
       DB 02h, 00h, 00h, 00h, 00h, 0F0h, 00h, 00h
       DB 3Fh, 00h, 0FFh, 00h, 00h, 00h, 00h, 00h
       DB 60h, 99h, 07h, 00h, 0C9h, 03h, 00h, 00h
       DB 00h, 00h, 00h, 00h, 02h, 00h, 00h, 00h
       DB 01h, 00h, 06h, 00h, 00h, 00h, 00h, 00h
       DB 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h
       DB 00h, 00h, 29h, 42h, 92h, 48h, 48h, 46h
       DB 52h, 45h, 45h, 2Dh, 44h, 4Fh, 53h, 20h
       DB 20h, 20h, 46h, 41h, 54h, 33h, 32h, 20h
       DB 20h, 20h, 0B8h, 0E0h, 1Fh, 0B9h, 00h, 7Ch
       DB 0FAh, 8Eh, 0D0h, 8Bh, 0E1h, 0FBh, 8Bh, 0F1h
       DB 8Bh, 0F9h, 8Eh, 0C0h, 50h, 33h, 0C0h, 8Eh
       DB 0D8h, 0B8h, 03h, 7Dh, 50h, 0B9h, 00h, 02h
       DB 0FCh, 0F3h, 0A4h, 0CBh, 00h, 00h, 10h, 00h
       DB 01h, 00h, 00h, 00h, 60h, 00h, 0B8h, 07h
       DB 59h, 00h, 00h, 00h, 00h, 00h, 0Dh, 0Ah
       DB 4Ch, 6Fh, 61h, 64h, 69h, 6Eh, 67h, 20h
       DB 46h, 72h, 65h, 65h, 44h, 4Fh, 53h, 20h
       DB 6Bh, 65h, 72h, 6Eh, 65h, 6Ch, 20h, 2Eh
       DB 2Eh, 2Eh, 00h, 4Fh, 6Bh, 2Eh, 0Dh, 0Ah
       DB 53h, 74h, 61h, 72h, 74h, 69h, 6Eh, 67h
       DB 20h, 46h, 72h, 65h, 65h, 44h, 4Fh, 53h
       DB 20h, 2Eh, 2Eh, 2Eh, 0Dh, 0Ah, 00h, 0Dh
       DB 0Ah, 45h, 72h, 72h, 6Fh, 72h, 20h, 6Ch
       DB 6Fh, 61h, 64h, 69h, 6Eh, 67h, 20h, 46h
       DB 72h, 65h, 65h, 44h, 4Fh, 53h, 20h, 6Bh
       DB 65h, 72h, 6Eh, 65h, 6Ch, 21h, 20h, 50h
       DB 72h, 65h, 73h, 73h, 20h, 61h, 6Eh, 79h
       DB 20h, 6Bh, 65h, 79h, 20h, 74h, 6Fh, 20h
       DB 72h, 65h, 62h, 6Fh, 6Fh, 74h, 20h, 2Eh
       DB 2Eh, 2Eh, 00h, 0Eh, 1Fh, 0BEh, 8Eh, 7Ch
       DB 0E8h, 0CBh, 00h, 2Eh, 8Bh, 0Eh, 88h, 7Ch
       DB 2Eh, 0C7h, 06h, 88h, 7Ch, 00h, 00h, 51h
       DB 0B4h, 41h, 0BBh, 0AAh, 55h, 0CDh, 13h, 59h
       DB 72h, 35h, 81h, 0FBh, 55h, 0AAh, 75h, 2Fh
       DB 0BEh, 7Eh, 7Ch, 51h, 0B8h, 00h, 42h, 0CDh
       DB 13h, 59h, 72h, 17h, 2Eh, 81h, 06h, 82h
       DB 7Ch, 00h, 02h, 2Eh, 83h, 16h, 84h, 7Ch
       DB 00h, 2Eh, 0FFh, 06h, 86h, 7Ch, 0E2h, 0E3h
       DB 0EBh, 7Ch, 90h, 0BEh, 0C7h, 7Ch, 0E8h, 85h
       DB 00h, 33h, 0C0h, 0CDh, 16h, 0CDh, 19h, 51h
       DB 52h, 0B4h, 08h, 0CDh, 13h, 80h, 0E1h, 3Fh
       DB 8Ah, 0D9h, 0FEh, 0C6h, 8Ah, 0FEh, 5Ah, 59h
       DB 72h, 0E1h, 80h, 0FBh, 00h, 74h, 0DCh, 2Eh
       DB 89h, 1Eh, 7Ch, 7Ch, 2Eh, 8Bh, 1Eh, 84h
       DB 7Ch, 8Eh, 0C3h, 33h, 0DBh, 51h, 53h, 52h
       DB 33h, 0D2h, 2Eh, 0A1h, 86h, 7Ch, 2Eh, 8Bh
       DB 1Eh, 7Ch, 7Ch, 32h, 0FFh, 0F7h, 0F3h, 8Bh
       DB 0CAh, 41h, 33h, 0D2h, 2Eh, 8Bh, 1Eh, 7Ch
       DB 7Ch, 8Ah, 0DFh, 32h, 0FFh, 0F7h, 0F3h, 8Bh
       DB 0DAh, 8Ah, 0E8h, 80h, 0E4h, 0C0h, 02h, 0CCh
       DB 5Ah, 8Ah, 0F3h, 5Bh, 0B8h, 01h, 02h, 0CDh
       DB 13h, 59h, 72h, 97h, 81h, 0C3h, 00h, 02h
       DB 8Ch, 0C0h, 15h, 00h, 00h, 8Eh, 0C0h, 2Eh
       DB 0FFh, 06h, 86h, 7Ch, 0E2h, 0B7h, 0BEh, 0ABh
       DB 7Ch, 0E8h, 0Ah, 00h, 8Ah, 0DAh, 0B8h, 60h
       DB 00h, 50h, 33h, 0C0h, 50h, 0CBh, 0B4h, 0Eh
       DB 0ACh, 3Ch, 00h, 74h, 04h, 0CDh, 10h, 0EBh
       DB 0F7h, 0C3h, 00h, 00h, 00h, 00h, 00h, 00h
       DB 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h
       DB 00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h
       DB 00h, 00h, 00h, 00h, 00h, 00h, 55h, 0AAh
	~

       COMMENT ~ No longer used
getSectorToBuffer:
       ld a,d
       or e
       jr nz,getStoredSector
       push hl
       ld bc,80h
       sbc hl,bc
       pop hl
       jr nc,getStoredSector
       ld bc,4000h
       ld (iMathPtr5),bc
       ld b,04h
       ld a,h
       or l
       jr nz,getSectorLoop
       ld a,d
       or e
       jr z,getSectorDone
getSectorLoop:
       push hl
       ld hl,(iMathPtr5)
       push bc
       ld bc,512
       add hl,bc
       pop bc
       bit 7,h
       jr z,$F
       ld hl,4000h
       inc b
$$:    ld (iMathPtr5),hl
       pop hl
       dec hl
       ld a,h
       or l
       jr nz,getSectorLoop
       ld a,d
       or e
       jr z,getSectorDone
       dec de
       ld a,d
       or e
       jr nz,getSectorLoop
getSectorDone:
       ld a,b
       cp 7
       ret nc
       ld hl,(iMathPtr5)
       ld de,8000h
       add hl,de
       di
       ld a,b
       out (5),a
       ld a,83h
       out (7),a
       ld de,sectorBuffer
       ld bc,512
       ldir
       ld a,81h
       out (7),a
       xor a
       out (5),a
       ret

storeSector:
       push de
       push hl
       di
       ld a,03h
       out (5),a
       ld hl,sectorBuffer+4000h
       ld de,savesscreen
       ld bc,512
       ldir
       xor a
       out (5),a
       pop hl
       pop de
       ld a,d
       or e
       ret nz
       push hl
       ld bc,80h
       sbc hl,bc
       pop hl
       ret nc
       ld bc,4000h
       ld (iMathPtr5),bc
       ld b,04h
       ld a,h
       or l
       jr nz,getSectorLoop2
       ld a,d
       or e
       jr z,getSectorDone2
getSectorLoop2:
       push hl
       ld hl,(iMathPtr5)
       push bc
       ld bc,512
       add hl,bc
       pop bc
       bit 7,h
       jr z,$F
       ld hl,4000h
       inc b
$$:    ld (iMathPtr5),hl
       pop hl
       dec hl
       ld a,h
       or l
       jr nz,getSectorLoop2
       dec de
       ld a,d
       or e
       jr nz,getSectorLoop2
getSectorDone2:
       ld a,b
       cp 7
       ret nc
       ld hl,(iMathPtr5)
       ld de,8000h
       add hl,de
       ex de,hl
       di
       ld a,b
       cp 7
       ret z
       out (5),a
       ld hl,savesscreen
       ld bc,512
       ldir
       xor a
       out (5),a
       ret

getStoredSector:
       push de
       push hl
       di
       ld a,83h
       out (7),a
       ld a,02h
       out (5),a
       ld hl,sectorBuffer
       ld (hl),0
       ld de,sectorBuffer+1
       ld bc,8191
       ldir
       ld a,81h
       out (7),a
       xor a
       out (5),a
       pop hl
       pop de
       push ix
       call getSectorPointer
       jr c,$F
       ld bc,4
       add ix,bc
       push ix
       pop hl
       ld a,83h
       out (7),a
       ld a,02h
       out (5),a
       ld de,sectorBuffer
       ld bc,512
       ldir
       ld a,81h
       out (7),a
       xor a
       out (5),a
$$:    pop ix
       ret
getSectorPointer:
       ld ix,sectorTable
getSectorPointerLoop:
       ld a,(ix+0)
       cp e
       jr nz,skipSector
       ld a,(ix+1)
       cp d
       jr nz,skipSector
       ld a,(ix+2)
       cp l
       jr nz,skipSector
       ld a,(ix+3)
       cp h
       jr nz,skipSector
;       ld bc,(curRow)                                   ;*** TESTING
;       push bc                                          ;
;       ld bc,3                                          ;
;       ld (curRow),bc                                   ;
;       ex de,hl                                         ;
;       call DispHexHL                                   ;
;       ex de,hl                                         ;
;       call DispHexHL                                   ;
;       pop bc                                           ;
;       ld (curRow),bc                                   ;
       ld a,d                                           ;*** TESTING
       or e                                             ;
       ret nz                                           ;
       or h                                             ;
       ret nz                                           ;
       ld a,l                                           ;
       cp 3Fh                                           ;
       jr nz,$F                                         ;
       ld a,5                                           ;
       B_CALL PutC                                      ;
$$:    or a
       ret
skipSector:
       ld a,(ix+0)
       inc a
       jr nz,$F
       ld a,(ix+1)
       inc a
       jr nz,$F
       ld a,(ix+2)
       inc a
       jr nz,$F
       ld a,(ix+3)
       inc a
       jr nz,$F
       scf
       ret
$$:    ld bc,4+512
       add ix,bc
       jr getSectorPointerLoop

sectorTable:
       ~

