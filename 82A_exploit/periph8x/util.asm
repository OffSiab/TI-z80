;Utility routines

 include "settings.inc"
 include "ti83plus.inc"
 include "equates.inc" 
 SEGMENT Main
 GLOBALS ON

 EXTERN debugStep

IPutS11:
       ld b,11
$$:    ld a,(hl)
       or a
       ret z
       inc hl
       call IPutC
       djnz $B
       ret

unlockFlash:
       ld hl,unlockFlashStart
       ld de,savesscreen
       ld bc,unlockFlashEnd-unlockFlashStart
       ldir
       jp savesscreen
unlockFlashStart:
; from 82a_exploit
;Unlocks Flash protection.
	in a,(6)
	push af
	in a,(0Eh)
	push af
	;Find the code to call
;#ifdef TI84PCSE
;	ld a,05h
;#else
	ld a,7Bh
;#endif
	call uoutputpage-unlockFlashStart+savesscreen
	ld ix,_WriteToFlash
	ld e,(ix+0)
	ld d,(ix+1)
	ld a,(ix+2)
	call uoutputpage-unlockFlashStart+savesscreen
	ld ix,unlockPattern-unlockFlashStart+savesscreen
	call FindPatternU-unlockFlashStart+savesscreen
	jr nz,unlockReturn
	;Jump into the routine
	set 5,(iy+1Bh)
	xor a
	ld (83A4h),a
	ld (822Fh),a
	ld (83A3h),a
	ld (8672h),a
	inc a
	ld (8432h),a
	ld bc,1
	ld hl,unlockReturn-unlockFlashStart+savesscreen
	push hl
	ld hl,(iMathPtr4)
	push hl
	push hl
	jp (hl)
unlockReturn:
	pop af
	out (0Eh),a
	pop af
	out (6),a
	ret
unlockRet:
	ret
unlockPattern:
	push af
	ld a,1
	nop
	di
	nop
	nop
	im 1
	di
	out (14h),a
	di
	call 0FEFEh
	pop af
	res 6,(iy+24h)
	res 7,(iy+24h)
	xor a
	ld (0FEFEh),a
	push bc
	ld a,(0FEFEh)
	cp 0
	db 28h,0FEh ;jr z,xx
	ld a,(0FEFEh)
	inc a
	ld (0FEFEh),a
	db 0CDh ;call...
	db 0FFh
FindPatternU:
;Pattern in IX, starting address in DE
;Returns NZ if pattern not found
;(iMathPtr4) contains the address of match found
;Search pattern:	terminated by 0FFh
;					0FEh is ? (one-byte wildcard)
;					0FCh is * (multi-byte wildcard)
	ld hl,unlockRet-unlockFlashStart+savesscreen
	push hl
	dec de
searchLoopRestartU:
	inc de
	ld (iMathPtr4),de
	push ix
	pop hl
searchLoopU:
	ld b,(hl)
	ld a,b
	inc a
	or a
	ret z
	inc de
	inc a
	jr z,matchSoFarU
	dec de
	inc a
	inc a
	ld c,a
	;At this point, we're either the actual byte (match or no match) (C != 0)
	;  or * wildcard (keep going until we find our pattern byte) (C == 0)
	or a
	jr nz,findByteU
	inc hl
	ld b,(hl)
findByteU:
	ld a,(de)
	inc de
	bit 7,d
	ret nz
	cp b
	jr z,matchSoFarU
	;This isn't it; do we start over at the beginning of the pattern,
	;  or do we keep going until we find that byte?
	inc c
	dec c
	jr z,findByteU
	ld de,(iMathPtr4)
	jr searchLoopRestartU
matchSoFarU:
	inc hl
	jr searchLoopU

uoutputpage:
	bit 7,a
	res 7,a
	ld b,a
	ld a,1
	jr nz,uopbig
	dec a
uopbig:
	out (0Eh),a
	ld a,b
	call utranslatePage-unlockFlashStart+savesscreen
	out (6),a
	ret
utranslatePage:
	ld b,a
	in a,(2)
	and 80h
	jr z,$F
	in a,(21h)
	and 3
	ld a,b
	ret nz
	and 3Fh
	ret
$$: ; _is83P
	ld a,b
	and 1Fh
	ret
unlockFlashEnd:

cphlde:
       push hl
       or a
       sbc hl,de
       pop hl
       ret

LDIR_ExtraRAMPage:
       call getAfromHL_ExtraRAMPage
       ex de,hl
       call putAtoHL_ExtraRAMPage
       ex de,hl
       inc hl
       inc de
       dec bc
       ld a,b
       or c
       jr nz,LDIR_ExtraRAMPage
       ret

LDIRtoExtraRAMPage:
       ex de,hl
$$:    ld a,(de)
       call putAtoHL_ExtraRAMPage
       inc hl
       inc de
       dec bc
       ld a,b
       or c
       jr nz,$B
       ex de,hl
       ret

LDIRtoDirEntries:
       ex de,hl
$$:    ld a,(de)
       call putAtoHL_dirEntries
       inc hl
       inc de
       dec bc
       ld a,b
       or c
       jr nz,$B
       ex de,hl
       ret

LDIRfromExtraRAMPage:
       call getAfromHL_ExtraRAMPage
       ld (de),a
       inc hl
       inc de
       dec bc
       ld a,b
       or c
       jr nz,LDIRfromExtraRAMPage
       ret

putAtoHL_ExtraRAMPage:
       push bc
       ld (asm_ram+6),a
       ld a,i
       jp pe,$F
       ld a,i
$$:    di
       push af
       ld a,(asm_ram+6)
       push af
       xor a
       out (0Fh),a
       pop bc
       ld a,02h
       out (5),a
       inc a
       or 80h
       out (7),a
       ld (hl),b
restoreRAMpagesRet:
       ld a,81h
       out (7),a
       xor a
       out (5),a
       ld (asm_ram+6),a
       pop af
       jp po,$F
       ei
$$:    ld a,(asm_ram+6)
       ld a,b
       pop bc
       ret

putAtoHL_dirEntries:
       push bc
       ld (asm_ram+6),a
       ld a,i
       jp pe,$F
       ld a,i
$$:    di
       push af
       ld a,(asm_ram+6)
       push af
       xor a
       out (0Fh),a ;I really don't know what this does
       pop bc
       ld a,06h
       out (5),a
       ld a,87h
       out (7),a
       ld (hl),b
       jr restoreRAMpagesRet

putAtoHL_FATtable:
       push bc
       ld (asm_ram+6),a
       ld a,i
       jp pe,$F
       ld a,i
$$:    di
       push af
       ld a,(asm_ram+6)
       push af
       xor a
       out (0Fh),a ;I really don't know what this does
       pop bc
       ld a,06h
       out (5),a
       ld a,87h
       out (7),a
       ld (hl),b
       jr restoreRAMpagesRet

putAtoHL_reverseFATtable:
       push bc
       ld (asm_ram+6),a
       ld a,i
       jp pe,$F
       ld a,i
$$:    di
       push af
       ld a,(asm_ram+6)
       push af
       xor a
       out (0Fh),a ;I really don't know what this does
       pop bc
       ld a,06h
       out (5),a
       ld a,87h
       out (7),a
       ld (hl),b
       jr restoreRAMpagesRet

getAfromHL_ExtraRAMPage:
       push bc
       ld (asm_ram+6),a
       ld a,i
       jp pe,$F
       ld a,i
$$:    di
       push af
       ld a,(asm_ram+6)
       xor a
       out (0Fh),a
       ld a,02h
       out (5),a
       inc a
       or 80h
       out (7),a
       ld b,(hl)
       jr restoreRAMpagesRet

WaitTimer100ms:
;Waits 100ms
       call WaitTimer20ms
       call WaitTimer20ms
       call WaitTimer20ms
WaitTimer40ms:
;Waits 40ms
       call WaitTimer20ms
WaitTimer20ms:
;Waits 20ms
       ld b,2
WaitTimerBms:
;Waits B*10 milliseconds
       ld a,42h
       out (36h),a
       xor a
       out (37h),a
       ld a,b
       out (38h),a
$$:    in a,(4)
       bit 7,a
       jr z,$B
       ret

DebugStart:
       push af
       push de
       push hl
       push bc
       ld hl,(curRow)
       push hl
       ld hl,2
       ld (curRow),hl
       ld a,6
;       ld b,1
;       call WaitTimerBms
       B_CALL PutC
       pop hl
       ld (curRow),hl
       pop bc
       pop hl
       pop de
       pop af
       ret
DebugStop:
       push af
       push de
       push hl
       push bc
       ld hl,(curRow)
       push hl
       ld hl,2
       ld (curRow),hl
       ld a,' '
;       ld b,1
;       call WaitTimerBms
       B_CALL PutC
       pop hl
       ld (curRow),hl
       pop bc
       pop hl
       pop de
       pop af
       ret

INewLine:
       push hl
       ld hl,(curRow)
       inc l
       ld h,0
       ld (curRow),hl
       pop hl
       ret

VPutSAppCenter:
       push hl
       call SStringLen
       pop hl
       ld a,95
       sub c
       srl a
       ld (penCol),a
VPutSApp:
       ld a,(hl)
       inc hl
       or a
       ret z
       B_CALL VPutMap
       jr VPutSApp
SStringLen:
       ld c,0
$$:    ld a,(hl)
       inc hl
       or a
       ret z
       push hl
       ld h,0
       ld l,a
       add hl,hl
       add hl,hl
       add hl,hl
       B_CALL SFont_Len
       ld a,b
       pop hl
       add a,c
       ld c,a
       jr $B

PutSApp:
       ld a,(hl)
       inc hl
       or a
       ret z
       B_CALL PutC
       jr PutSApp
DoDebug:
	push af
	push hl
       push bc
       push de
       push ix
       ld a,(debugStep)
       cp 0FFh
       jr z,$F
       ld (curRow),a
       ld a,14
       ld (curCol),a
       ld a,' '
       B_CALL PutMap
$$:	ld hl,debugStep
	inc (hl)
	ld a,(hl)
	ld hl,(curRow)
	push hl
       cp 7
       jr nz,$F
       xor a
       ld (debugStep),a
$$:	ld (curRow),a
	xor a
	ld (curCol),a
       ld a,(inputBuffer)
       call DispHexA
	ld a,(inputBuffer+1)
       call DispHexA
       ld a,(inputBuffer+2)
       call DispHexA
       ld a,(inputBuffer+3)
       call DispHexA
       ld a,(inputBuffer+4)
       call DispHexA
       ld a,(inputBuffer+5)
       call DispHexA
       ld a,(inputBuffer+6)
       call DispHexA
       ld a,14
       ld (curCol),a
       ld a,5
       B_CALL PutMap
	pop hl
	ld (curRow),hl
       pop ix
       pop de
       pop bc
	pop hl
	pop af
	ret

IGetKey:
       push ix
       push bc
       push de
       push hl
       res onInterrupt,(iy+onFlags)
       B_CALL GetKey
       pop hl
       pop de
       pop bc
       pop ix
       ret

IPutSUnicode:
;Display a unicode string descriptor
       ld     b,(hl)
       inc    hl
       inc    hl
       dec    b
       dec    b
$$:
       ld     a,(hl)
       or     a
       call   nz,IPutC
       inc    hl
       djnz   $b
       ret

IPutS:
       ld     a,(hl)
       inc    hl
       or     a
       ret    z
       call   IPutC
       jr     IPutS

IPutC:
       push   hl ;don't think these are necessary
       push   bc
       B_CALL PutC
       pop    bc
       pop    hl
       ret
       
 Var TempNum,2
GetHexA:
;lets user input an 8 bit number in hexadecimal
;prompt is at currow,curcol
;number is returned in a
	set curAble,(iy+curFlags)
	ld	b,2
	ld	hl,TempNum
getnumhloop:
   call IGetKey
	cp	2
	jp	nz,gnhnotback
	ld	a,b
	cp	2
	jp	z,gnhnotback
	ld	a,' '
   B_CALL PutMap
	ld	hl,curCol
	dec (hl)
	jp	GetHexA
gnhnotback:
	sub 142
	cp	10
	jp	c,gnhnumpressed
	sub 12
	cp	6
	jp	c,gnhletpressed
	jp	getnumhloop
gnhnumpressed:
	ld	(hl),a
	inc hl
	add a,48
	call IPutC
	djnz getnumhloop
	jp	gnhdone
gnhletpressed:
	add a,10
	ld	(hl),a
	inc hl
	add a,55
   call IPutC
	djnz getnumhloop
gnhdone:
	dec hl
	ld	b,(hl)
	dec hl
	ld	a,(hl)
	rlca
	rlca
	rlca
	rlca
	or	b
   res curAble,(iy+curFlags)
	ret

DispHexHL:
   push af
	push bc
	push de
	push hl
	push ix
   ld a,h
   call DispHexA
   ld a,l
   call DispHexA
	pop ix
	pop hl
	pop de
	pop bc
   pop af
   ret

DispHexA:
	push ix
	push af
   push hl
   push bc
   push af
   rrca
   rrca
   rrca
   rrca
   call dispha
   pop af
   call dispha
   pop bc
   pop hl
	pop af
	pop ix
   ret
dispha:
   and 15
   cp 10
   jp nc,dhlet
   add a,48
   jp dispdh
dhlet:
   add a,55
dispdh:
   call IPutC
   ret

;DialogBox
; Input
;  (H,L) = (y,x) upper left
;  (D,E) = (y,x) lower right
;H and l must be >= 1
;D must be <= 62
;E must be <= 93
;Text inside the box must be displayed manually
DialogBox:
	push hl
	push de
	dec h
	dec l
	inc d 
	inc d
	inc e
	inc e
	B_CALL EraseRectBorder
	pop de
	pop hl
	push hl
	push de
	B_CALL DrawRectBorderClear	
	pop de
	pop hl
	push hl
	push de
	inc d
	inc e
	B_CALL DrawRectBorder
	pop de
	pop hl
	ld	a,h
	xor 63 ;Adjust for funny IPoint coordinates
	ld	h,a 
	ld	a,d
	xor 63
	ld	b,l
	ld	c,h
	ld	d,0
	B_CALL IPoint ;(b,c) = (x,y xor 63) - upper left
	ld	b,e
	B_CALL IPoint
	inc b
	B_CALL IPoint
	dec c
	B_CALL IPoint
	ld	c,a
	dec c
	B_CALL IPoint
	ld	b,l
	B_CALL IPoint
	inc b
	B_CALL IPoint
	dec b
	inc c
	B_CALL IPoint
	ret

VStrLen:
	ld b,0
VStrLen_Loop:
	ld a,(hl)
	or a
	ret z
	push hl
	ld h,0
	ld l,a
	add hl,hl
	add hl,hl
	add hl,hl
	push bc
	B_CALL SFont_Len
	ld a,b
	pop bc
	pop hl
	inc hl
	add a,b
	ld b,a
	jr VStrLen_Loop
