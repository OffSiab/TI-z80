;periph8x entry points

 include "settings.inc"
 include "ti83plus.inc"
 include "equates.inc" 
 SEGMENT Main
 GLOBALS ON

 EXTERN USBactivityHook,InitializePeriphUSB,SendInterruptData,WaitTimer100ms,DispHexA,initUSBStuff,initCrystalTimer
 EXTERN HIDdeviceDescriptor,HIDconfigDescriptor,MSDdeviceDescriptor,MSDconfigDescriptor,receiveAndWriteUSBData,DispHexHL
 EXTERN ReceiveData,SendBulkData,getSectorToBuffer,SendData,ReceiveLargeData,WaitTimerBms,sendUSBData_BCbytesFromHL,storeSector
 EXTERN putAtoHL_ExtraRAMPage,handleReadSectorEvent,handleWriteSectorEvent,calcDeviceDescriptor,calcConfigDescriptor,bufferPtr
 EXTERN calcSEDeviceDescriptor,receiveAndWriteUSBData_noInt,CalculateMSDVariableData,receiveAndWriteUSBData_fromInt,RecycleUSB

DriverVersion:
;Returns periph8x version.
;Inputs:      None
;Outputs:     HL is version (H major, L minor)
;             DE is build
;             A is flags byte (all zeroes)
       ld hl,VERSION
       ld de,BUILD
       xor a
       ret

DriverInit:
;Initializes periph8x driver.
;Inputs:      B is flags byte (all zeroes)
;Outputs:     Returns carry set if problems
;             A is return data (all zeroes)
       xor a
       ld (USBflag),a
       B_CALL KillUSB                            ;kill USB peripheral link (this must come first, apparently)
       B_CALL KillUSBDevice                      ;kill any attached USB peripheral
       xor a
       ret

DriverKill:
;Kills periph8x driver (and "disconnects" from the host).
;Inputs:      None
;Outputs:     Returns carry set if problems
;       B_CALL KillUSB
       B_CALL DisableUSBActivityHook
	B_CALL KillUSB
       call WaitTimer100ms
       call InitializePeriphUSB
       xor a
       ret

CalculatorInit:
;Initializes calculator driver.
;Inputs:      B is flags byte
;                    Bit 0: set to initialize immediately, or reset to initialize on connect.
;Outputs:     Returns carry set if problems
       bit 0,b
       jr z,$F
       call InitializePeriphUSB
       ;ret c
$$:    ld hl,USBflag
       set calcActive,(hl)
       res kbdActive,(hl)
       res msdActive,(hl)
       res mouseActive,(hl)
       res gamepadActive,(hl)
       ld hl,appBackUpScreen
       ld (bufferPtr),hl
       ld hl,calcDeviceDescriptor
       in a,(21h)
       and 3
       jr z,$F
       ld hl,calcSEDeviceDescriptor
$$:    ld (deviceDescAddress),hl
       ld hl,calcConfigDescriptor
       ld (configDescAddress),hl
       ld hl,USBactivityHook
       in a,(6)
       B_CALL EnableUSBActivityHook
       xor a
       ret

MouseInit:
;Initializes mouse driver.
;Inputs:      B is flags byte
;                    Bit 0: set to initialize immediately, or reset to initialize on connect.
;Outputs:     Returns carry set if problems
       scf
       ret
       bit 0,b
       jr z,$F
       call InitializePeriphUSB
       ;ret c
$$:    ld hl,USBflag
       res kbdActive,(hl)
       res msdActive,(hl)
       res calcActive,(hl)
       set mouseActive,(hl)
       res gamepadActive,(hl)
       ld hl,HIDdeviceDescriptor
       ld (deviceDescAddress),hl
       ld hl,HIDconfigDescriptor
       ld (configDescAddress),hl
       ld hl,USBactivityHook
       in a,(6)
       B_CALL EnableUSBActivityHook
       xor a
       ret

GamepadInit:
;Initializes gamepad driver.
;Inputs:      B is flags byte
;                    Bit 0: set to initialize immediately, or reset to initialize on connect.
;Outputs:     Returns carry set if problems
       scf
       ret
       bit 0,b
       jr z,$F
       call InitializePeriphUSB
       ;ret c
$$:    ld hl,USBflag
       res kbdActive,(hl)
       res msdActive,(hl)
       res calcActive,(hl)
       res mouseActive,(hl)
       set gamepadActive,(hl)
       ld hl,HIDdeviceDescriptor
       ld (deviceDescAddress),hl
       ld hl,HIDconfigDescriptor
       ld (configDescAddress),hl
       ld hl,USBactivityHook
       in a,(6)
       B_CALL EnableUSBActivityHook
       xor a
       ret

KeyboardInit:
;Initializes keyboard driver.
;Inputs:      B is flags byte
;                    Bit 0: set to initialize immediately, or reset to initialize on connect.
;Outputs:     Returns carry set if problems
       bit 0,b
       jr z,skipHIDPeriphInit
       call InitializePeriphUSB
       ;ret c
skipHIDPeriphInit:
       ld hl,USBflag
       set kbdActive,(hl)
       res msdActive,(hl)
       res calcActive,(hl)
       res mouseActive,(hl)
       res gamepadActive,(hl)
       ld hl,HIDdeviceDescriptor
       ld (deviceDescAddress),hl
       ld hl,HIDconfigDescriptor
       ld (configDescAddress),hl
       ld hl,USBactivityHook
       in a,(6)
       B_CALL EnableUSBActivityHook
       xor a
       ret

SendKeypress:
;Fakes a USB keyboard keypress as if you had typed it.
;Inputs:      A is key code type
;                    A = 0: GetKey code
;                    A = 1: HID code (no translation)
;                    A = 2: ASCII character
;             B is flags byte (all zeroes)
;             C is key code (and (keyExtend) if GetKey code being sent)
;             D is modifier byte (if HID code being sent, zero default)
;Outputs:     Returns carry if problems or invalid key code
       push bc
       push de
       ld hl,outputBuffer
       ld (hl),0
       ld de,outputBuffer+1
       ld bc,15
       ldir
       pop de
       pop bc
       or a
       jr nz,$F
       ld a,c
       call translateKeyCode
       jr nc,sendKeycode
       ret
$$:    dec a
       ld a,c
       jr z,sendKeycode
       ;TODO: convert ASCII character
       ;Input:  A = ASCII character
       ;Output: A = key code
       ;        D = modifier byte
sendKeycode:
       ld (outputBuffer+2),a
       ld a,d
       ld (outputBuffer),a
       call sendKeypressData
       ld de,01FFh                        ;*** HACK: I don't remember why I did this
$$:    dec de                             ;
       ld a,d                             ;
       or e                               ;
       jr nz,$B                           ;
       call clearKeypress
$$:    xor a
       ret
clearKeypress:
       ld hl,outputBuffer
       ld (hl),0
       ld de,outputBuffer+1
       ld bc,7
       ldir
sendKeypressData:
       ld hl,outputBuffer
       ld b,8
       ld c,1
       jr SendInterruptData
translateKeyCode:
;Input:  A = GetKey code (and (keyExtend) if necessary)
;Output: A = key code
;        D = modifier byte
       cp 0FCh
       jr nz,$F
       ld a,(keyExtend)
       cp 0E2h
       jp m,tkcError
       cp 0E2h+26
       jp p,tkcError
       sub 0E2h-4
       ld d,0
       or a
       ret
$$:    ld h,0
       ld l,a
       add hl,hl
       ld bc,GetKeyTable
       add hl,bc
       ld a,(hl)
       inc hl
       ld d,(hl)
       or a
       scf
       ret z
       or a
       ret
tkcError:
       xor a
       ld d,a
       scf
       ret
GetKeyTable:
       DB 00h,00h ;00h
       DB 4Fh,00h ;01h ;kRight
       DB 50h,00h ;02h ;kLeft
       DB 52h,00h ;03h ;kUp
       DB 51h,00h ;04h ;kDown
       DB 58h,00h ;05h ;kEnter
       DB 00h,00h ;06h ;kAlphaEnter
       DB 00h,00h ;07h ;kAlphaUp
       DB 00h,00h ;08h ;kAlphaDown
       DB 00h,00h ;09h ;kClear
       DB 4Ch,00h ;0Ah ;kDel
       DB 49h,00h ;0Bh ;kIns
       DB 00h,00h ;0Ch ;kRecall
       DB 00h,00h ;0Dh ;kLastEnt
       DB 00h,00h ;0Eh ;kBOL
       DB 00h,00h ;0Fh ;kEOL
       DB 00h,00h ;10h ;kSelAll
       DB 00h,00h ;11h ;kUnselAll
       DB 00h,00h ;12h ;kLtoTI82
       DB 00h,00h ;13h ;kBackup
       DB 00h,00h ;14h ;kReceive
       DB 00h,00h ;15h ;kLnkQuit
       DB 00h,00h ;16h ;kTrans
       DB 00h,00h ;17h ;kRename
       DB 00h,00h ;18h ;kOverw
       DB 00h,00h ;19h ;kOmit
       DB 00h,00h ;1Ah ;kCont
       DB 00h,00h ;1Bh ;kSendID
       DB 00h,00h ;1Ch ;kSendSW
       DB 00h,00h ;1Dh ;kYes
       DB 00h,00h ;1Eh ;kNoWay
       DB 00h,00h ;1Fh ;kvSendType
       DB 00h,00h ;20h ;kOverWAll
       DB 00h,00h ;21h
       DB 00h,00h ;22h
       DB 00h,00h ;23h
       DB 00h,00h ;24h
       DB 00h,00h ;25h ;kNo
       DB 00h,00h ;26h ;kKReset
       DB 00h,00h ;27h ;kApp
       DB 00h,00h ;28h ;kDoug
       DB 00h,00h ;29h ;kListflag
       DB 00h,00h ;2Ah
       DB 00h,00h ;2Bh ;menuStart
       DB 00h,00h ;2Ch ;kAppsMenu
       DB 00h,00h ;2Dh ;kPrgm
       DB 3Ch,00h ;2Eh ;kZoom
       DB 00h,00h ;2Fh ;kDraw
       DB 3Fh,00h ;30h ;kSPlot
       DB 00h,00h ;31h ;kStat
       DB 1Eh,02h ;32h ;kMath
       DB 00h,00h ;33h ;kTest
       DB 00h,00h ;34h ;kChar
       DB 2Ah,00h ;35h ;kVars
       DB 34h,00h ;36h ;kMem
       DB 00h,00h ;37h ;kMatrix
       DB 00h,00h ;38h ;kDist
       DB 00h,00h ;39h ;kAngle
       DB 00h,00h ;3Ah ;kList
       DB 42h,00h ;3Bh ;kCalc
       DB 00h,00h ;3Ch ;kFin
       DB 00h,00h ;3Dh
       DB 00h,00h ;3Eh ;kCatalog
       DB 00h,00h ;3Fh ;kInputDone
       DB 29h,00h ;40h ;kQuit
       DB 00h,00h ;41h ;kLinkIO
       DB 00h,00h ;42h ;kMatrixEd
       DB 00h,00h ;43h ;kStatEd
       DB 3Eh,00h ;44h ;kGraph
       DB 00h,00h ;45h ;kMode
       DB 00h,00h ;46h ;kPrgmEd
       DB 00h,00h ;47h ;kPrgmCr
       DB 3Bh,00h ;48h ;kWindow
       DB 3Ah,00h ;49h ;kYequ
       DB 43h,00h ;4Ah ;kTable
       DB 40h,00h ;4Bh ;kTblSet
       DB 00h,00h ;4Ch ;kChkRAM
       DB 00h,00h ;4Dh ;kDelMem
       DB 00h,00h ;4Eh ;kResetMem
       DB 00h,00h ;4Fh ;kResetDef
       DB 00h,00h ;50h ;kPrgmInput
       DB 00h,00h ;51h ;kZFactEd
       DB 00h,00h ;52h ;kError
       DB 00h,00h ;53h ;kSolveTVM
       DB 00h,00h ;54h ;kSolveRoot
       DB 00h,00h ;55h ;kStatP
       DB 00h,00h ;56h ;kInfStat
       DB 41h,00h ;57h ;kFormat
       DB 00h,00h ;58h ;kExtApps
       DB 00h,00h ;59h ;kNewApps
       DB 3Dh,00h ;5Ah ;kTrace
       DB 00h,00h ;5Bh ;kZFit
       DB 00h,00h ;5Ch ;kZIn
       DB 00h,00h ;5Dh ;kZOut
       DB 00h,00h ;5Eh ;kZPrev
       DB 00h,00h ;5Fh ;kBox
       DB 00h,00h ;60h ;kDecml
       DB 00h,00h ;61h ;kSetZm
       DB 00h,00h ;62h ;kSquar
       DB 00h,00h ;63h ;kStd
       DB 00h,00h ;64h ;kTrig
       DB 00h,00h ;65h ;kUsrZm
       DB 00h,00h ;66h ;kZSto
       DB 00h,00h ;67h ;kZInt
       DB 00h,00h ;68h ;kZStat
       DB 00h,00h ;69h ;kSelect
       DB 00h,00h ;6Ah ;kCircl
       DB 00h,00h ;6Bh ;kClDrw
       DB 00h,00h ;6Ch ;kLine
       DB 00h,00h ;6Dh ;kPen
       DB 00h,00h ;6Eh ;kPtChg
       DB 00h,00h ;6Fh ;kPtOff
       DB 00h,00h ;70h ;kPtOn
       DB 00h,00h ;71h ;kVert
       DB 00h,00h ;72h ;kHoriz
       DB 00h,00h ;73h ;kText
       DB 00h,00h ;74h ;kTanLn
       DB 00h,00h ;75h ;kEval
       DB 00h,00h ;76h ;kInters
       DB 00h,00h ;77h ;kDYDX
       DB 00h,00h ;78h ;kFnIntg
       DB 00h,00h ;79h ;kRootG
       DB 00h,00h ;7Ah ;kDYDT
       DB 00h,00h ;7Bh ;kDXDT
       DB 00h,00h ;7Ch ;kDRDo
       DB 00h,00h ;7Dh ;KGFMin
       DB 00h,00h ;7Eh ;KGFMax
       DB 00h,00h ;7Fh ;kListName
       DB 2Eh,02h ;80h ;kAdd
       DB 2Dh,00h ;81h ;kSub
       DB 25h,02h ;82h ;kMul
       DB 38h,00h ;83h ;kDiv
       DB 00h,00h ;84h ;kExpon
       DB 26h,02h ;85h ;kLParen
       DB 27h,02h ;86h ;kRParen
       DB 2Fh,00h ;87h ;kLBrack
       DB 30h,00h ;88h ;kRBrack
       DB 00h,00h ;89h ;kShade
       DB 00h,00h ;8Ah ;kStore
       DB 36h,00h ;8Bh ;kComma
       DB 2Dh,02h ;8Ch ;kChs
       DB 37h,00h ;8Dh ;kDecPnt
       DB 27h,00h ;8Eh ;k0
       DB 1Eh,00h ;8Fh ;k1
       DB 1Fh,00h ;90h ;k2
       DB 20h,00h ;91h ;k3
       DB 21h,00h ;92h ;k4
       DB 22h,00h ;93h ;k5
       DB 23h,00h ;94h ;k6
       DB 24h,00h ;95h ;k7
       DB 25h,00h ;96h ;k8
       DB 26h,00h ;97h ;k9
       DB 00h,00h ;98h ;kEE
       DB 2Ch,00h ;99h ;kSpace
       DB 04h,02h ;9Ah ;kCapA
       DB 05h,02h ;9Bh ;kCapB
       DB 06h,02h ;9Ch ;kCapC
       DB 07h,02h ;9Dh ;kCapD
       DB 08h,02h ;9Eh ;kCapE
       DB 09h,02h ;9Fh ;kCapF
       DB 0Ah,02h ;0A0h ;kCapG
       DB 0Bh,02h ;0A1h ;kCapH
       DB 0Ch,02h ;0A2h ;kCapI
       DB 0Dh,02h ;0A3h ;kCapJ
       DB 0Eh,02h ;0A4h ;kCapK
       DB 0Fh,02h ;0A5h ;kCapL
       DB 10h,02h ;0A6h ;kCapM
       DB 11h,02h ;0A7h ;kCapN
       DB 12h,02h ;0A8h ;kCapO
       DB 13h,02h ;0A9h ;kCapP
       DB 14h,02h ;0AAh ;kCapQ
       DB 15h,02h ;0ABh ;kCapR
       DB 16h,02h ;0ACh ;kCapS
       DB 17h,02h ;0ADh ;kCapT
       DB 18h,02h ;0AEh ;kCapU
       DB 19h,02h ;0AFh ;kCapV
       DB 1Ah,02h ;0B0h ;kCapW
       DB 1Bh,02h ;0B1h ;kCapX
       DB 1Ch,02h ;0B2h ;kCapY
       DB 1Dh,02h ;0B3h ;kCapZ
       DB 00h,00h ;0B4h ;kVarx
       DB 00h,00h ;0B5h ;kPi
       DB 00h,00h ;0B6h ;kInv
       DB 00h,00h ;0B7h ;kSin
       DB 00h,00h ;0B8h ;kASin
       DB 00h,00h ;0B9h ;kCos
       DB 00h,00h ;0BAh ;kACos
       DB 00h,00h ;0BBh ;kTan
       DB 00h,00h ;0BCh ;kATan
       DB 00h,00h ;0BDh ;kSquare
       DB 00h,00h ;0BEh ;kSqrt
       DB 00h,00h ;0BFh ;kLn
       DB 00h,00h ;0C0h ;kExp
       DB 00h,00h ;0C1h ;kLog
       DB 00h,00h ;0C2h ;kALog
       DB 00h,00h ;0C3h ;kToABC
       DB 00h,00h ;0C4h ;kClrTbl
       DB 00h,00h ;0C5h ;kAns
       DB 33h,02h ;0C6h ;kColon
       DB 00h,00h ;0C7h ;kNDeriv
       DB 00h,00h ;0C8h ;kFnInt
       DB 00h,00h ;0C9h ;kRoot
       DB 00h,00h ;0CAh ;kQuest
       DB 34h,02h ;0CBh ;kQuote
       DB 00h,00h ;0CCh ;kTheta
       DB 00h,00h ;0CDh ;kIf
       DB 00h,00h ;0CEh ;kThen
       DB 00h,00h ;0CFh ;kElse
       DB 00h,00h ;0D0h ;kFor
       DB 00h,00h ;0D1h ;kWhile
       DB 00h,00h ;0D2h ;kRepeat
       DB 00h,00h ;0D3h ;kEnd
       DB 00h,00h ;0D4h ;kPause
       DB 00h,00h ;0D5h ;kLbl
       DB 00h,00h ;0D6h ;kGoto
       DB 00h,00h ;0D7h ;kISG
       DB 00h,00h ;0D8h ;kDSL
       DB 00h,00h ;0D9h ;kMenu
       DB 00h,00h ;0DAh ;kExec
       DB 00h,00h ;0DBh ;kReturn
       DB 00h,00h ;0DCh ;kStop
       DB 00h,00h ;0DDh ;kInput
       DB 00h,00h ;0DEh ;kPrompt
       DB 00h,00h ;0DFh ;kDisp
       DB 00h,00h ;0E0h ;kDispG
       DB 00h,00h ;0E1h ;kDispT
       DB 00h,00h ;0E2h ;kOutput
       DB 00h,00h ;0E3h ;kGetKey
       DB 00h,00h ;0E4h ;kClrHome
       DB 00h,00h ;0E5h ;kPrtScr
       DB 00h,00h ;0E6h ;kSinH
       DB 00h,00h ;0E7h ;kCosH
       DB 00h,00h ;0E8h ;kTanH
       DB 00h,00h ;0E9h ;kASinH
       DB 00h,00h ;0EAh ;kACosH
       DB 00h,00h ;0EBh ;kATanH
       DB 2Fh,02h ;0ECh ;kLBrace
       DB 30h,02h ;0EDh ;kRBrace
       DB 00h,00h ;0EEh ;kI
       DB 00h,00h ;0EFh ;kCONSTeA
       DB 00h,00h ;0F0h ;kPlot3
       DB 00h,00h ;0F1h ;kFMin
       DB 00h,00h ;0F2h ;kFMax
       DB 00h,00h ;0F3h ;kL1A
       DB 00h,00h ;0F4h ;kL2A
       DB 00h,00h ;0F5h ;kL3A
       DB 00h,00h ;0F6h ;kL4A
       DB 00h,00h ;0F7h ;kL5A
       DB 00h,00h ;0F8h ;kL6A
       DB 00h,00h ;0F9h ;kunA
       DB 00h,00h ;0FAh ;kvnA
       DB 00h,00h ;0FBh ;kwnA

MassStorageInit:
;Initializes mass storage driver.
;Inputs:      B is flags byte
;                    Bit 0: set to initialize immediately, or reset to initialize on connect.
;Outputs:     Returns carry set if problems
;Notes:       This driver uses every RAM page.
;             Zone 0: Pages 81h\80h - used by OS.
;             Zone 1: Pages 83h\82h - temporary sector buffer for host sends/receives.
;             Zone 2: Pages 85h\84h - FAT tables. 85h has the FAT as the host sees it, 84h is a reverse linked list.
;             Zone 3: Pages 87h\86h - scratch space for directory entries.
;Since page 87h is used, logging must be disabled for this to work properly.
       res 5,(iy+41h)
       bit 0,b
       jr z,skipMSDPeriphInit
       or a
       in a,(4Dh)
       bit 6,a
       call nz,InitializePeriphUSB
       ;ret c
skipMSDPeriphInit:
       ld hl,USBflag
       set msdActive,(hl)
       res kbdActive,(hl)
       res calcActive,(hl)
       res mouseActive,(hl)
       res gamepadActive,(hl)
       ld hl,MSDdeviceDescriptor
       ld (deviceDescAddress),hl
       ld hl,MSDconfigDescriptor
       ld (configDescAddress),hl
       ld hl,USBactivityHook
       in a,(6)
       B_CALL EnableUSBActivityHook
       ;Prepare FAT table
       di
       ld a,85h
       out (7),a
       ld a,04h
       out (5),a
       ld hl,8000h
       ld (hl),0
       ld de,8001h
       ld bc,8000h-1
       ldir
       ld hl,8000h
       ld (hl),0F8h
       inc hl
       ld (hl),0FFh
       inc hl
       ld (hl),0FFh
       inc hl
       ld (hl),0FFh
       inc hl
       ld (hl),0FFh
       inc hl
       ld (hl),0FFh
       inc hl
       ld (hl),0FFh
       inc hl
       ld (hl),0FFh
       ld a,81h
       out (7),a
       xor a
       out (5),a
       jr CalculateMSDVariableData

;This stuff is finally handled in the interrupt
;MassStorageHandle:
;Handles mass storage requests.
;       ei
;       nop
;       nop
;       bit 5,(iy+41h)
;       ret z                              ;no data to read
DoMassStorageHandle:
;       ld a,1
;       B_CALL PutC
       ld hl,inputBuffer
       ld bc,31
       res 4,(iy+43h)                     ;*** HACK: might want to clean up this whole process
       res useExtraRAMPages,(iy+periph8xFlags)
       call receiveAndWriteUSBData_fromInt       ;apparently the first receive must use this routine
       di
       ld a,(inputBuffer)
       cp 'U'
       jr nz,invalidCommandReceived       ;*** HACK: quick sanity check
       ld hl,(inputBuffer+4)              ;MSD command response
       ld (asm_ram),hl                    ;
       ld hl,(inputBuffer+6)              ;
       ld (asm_ram+2),hl                  ;
       ld a,(inputBuffer+15)              ;
;       ld hl,0                            ;*** TESTING
;       ld (curRow),hl                     ;
;       call DispHexA                      ;
       LOG MSDCmd,a
       or a
       jr z,sendStatusData
       cp 1Eh
       jr z,sendStatusData ;prevent/allow medium removal, (inputBuffer+19) = 1 for disable, 0 for enable
       cp 12h
       jr z,inquiryReceived
       cp 1Ah
       jr z,command1AhReceived
       cp 23h
       jr z,readFormatCapacityReceived
       cp 25h
       jr z,readCapacityReceived
       cp 28h
       jr z,readSectorReceived
       cp 2Ah
       jr z,writeSectorReceived
invalidCommandReceived:
       ld a,(inputBuffer+15)
       LOG InvalidMSDCmd,a ;weird command received
       ret
writeSectorReceived:
       res 0,(iy+41h) ;read data override flag
       ld a,1
       out (5Bh),a
;       ei
       ld a,(inputBuffer+23)
       inc a
       ld b,a
       push af
       ld hl,-512
       ld de,512
$$:    add hl,de
       djnz $B
       ld b,h
       ld c,l
       ld hl,sectorBuffer
       res 4,(iy+43h)
       set useExtraRAMPages,(iy+periph8xFlags)
       call receiveAndWriteUSBData_noInt
       res indicOnly,(iy+indicFlags)
       pop bc
       jr nc,$F
       ld a,(bytesRemaining)
       LOG WriteError,a
$$:    push bc
       di
;       ld hl,sectorBuffer                 ;*** HACK: this stuff stores the sector to an extra RAM page, for testing
;       ld de,0C000h                       ;
;       ld a,05h                           ;
;       out (5),a                          ;
;       ld bc,512                          ;
;       ldir                               ;
;       xor a                              ;
;       out (5),a                          ;
       ld de,(inputBuffer+17)             ;
       ld a,d                             ;
       ld d,e                             ;
       ld e,a                             ;
       ld hl,(inputBuffer+19)             ;
       ld a,h                             ;
       ld h,l                             ;
       ld l,a                             ;
       LOG SectorWrite,d                  ;
       LOG SectorWrite,e                  ;
       LOG SectorWrite,h                  ;
       LOG SectorWrite,l                  ;
;put sectorBuffer to DE:HL                ;
;       call storeSector                   ;
       pop af
       call handleWriteSectorEvent
       jr sendStatusData
readSectorReceived:
       ld a,(inputBuffer+23)
       inc a
       ld b,a
       push af
       ld hl,-512
       ld de,512
$$:    add hl,de
       djnz $B
       ld (asm_ram+4),hl
       ld de,(inputBuffer+17)
       ld a,d
       ld d,e
       ld e,a
       ld hl,(inputBuffer+19)
       ld a,h
       ld h,l
       ld l,a
       LOG SectorRead,d
       LOG SectorRead,e
       LOG SectorRead,h
       LOG SectorRead,l
       ld bc,(asm_ram+4)
       pop af
       call handleReadSectorEvent ;call getSectorToBuffer
       ld hl,sectorBuffer
       ld bc,(asm_ram+4)
       add hl,bc
       push hl
       ld b,13
$$:    xor a
       call putAtoHL_ExtraRAMPage
       inc hl
       djnz $B
       pop hl
       ld de,sUSBS
       ld b,4
$$:    ld a,(de)
       call putAtoHL_ExtraRAMPage
       inc hl
       inc de
       djnz $B
       ld a,(asm_ram)
       call putAtoHL_ExtraRAMPage
       inc hl
       ld a,(asm_ram+1)
       call putAtoHL_ExtraRAMPage
       inc hl
       ld a,(asm_ram+2)
       call putAtoHL_ExtraRAMPage
       inc hl
       ld a,(asm_ram+3)
       call putAtoHL_ExtraRAMPage
       ld hl,(asm_ram+4)
       ld bc,13
       add hl,bc
       ld b,h
       ld c,l
       ld hl,sectorBuffer
       set useExtraRAMPages,(iy+periph8xFlags)
       jr sendUSBData_BCbytesFromHL
readFormatCapacityReceived:
       ld hl,formatCapacity
       ld bc,12
       jr sendUFIData
readCapacityReceived:
       ld hl,capacityData
       ld bc,8
       jr sendUFIData
command1AhReceived:
       ld hl,modeSense1C
       ld bc,modeSense1CEnd-modeSense1C
       ld a,(inputBuffer+17)
       cp 1Ch
       cp a
       jr z,sendUFIData
       ld hl,modeSense3F
       ld bc,modeSense3FEnd-modeSense3F
       cp 3Fh
       jr z,sendUFIData
       LOG Custom,0FEh                                                ;*** TESTING
       jr sendStatusData
inquiryReceived:
       ld hl,inquiryData
       ld bc,36
sendUFIData:
       res useExtraRAMPages,(iy+periph8xFlags)
       call sendUSBData_BCbytesFromHL
sendStatusData:
       ld hl,inputBuffer
       ld bc,13
       B_CALL MemClear
       ld hl,sUSBS
       ld de,inputBuffer
       ld bc,4
       ldir
       ex de,hl
       ld de,(asm_ram)
       ld (hl),e
       inc hl
       ld (hl),d
       inc hl
       ld de,(asm_ram+2)
       ld (hl),e
       inc hl
       ld (hl),d
       ld hl,inputBuffer
       ld bc,13
       res useExtraRAMPages,(iy+periph8xFlags)
       call sendUSBData_BCbytesFromHL
       res 5,(iy+41h)
;       ei
       ret
sUSBS:
       DB "USBS"
inquiryData:
       DB 00h,80h,00h,01h,1Fh ;stuff, second byte is 80h for removable media, otherwise 00h
       DB 00h,00h,00h         ;reserved
       DB "TI      "          ;vendor information
       DB "Drive           "  ;product information
       DB "v0.01"             ;product revision level
formatCapacity:
       DB 00h,00h,00h         ;reserved
       DB 08h                 ;capacity list length
       DB 00h,00h,10h,00h     ;number of blocks (sectors) (2MB)
       DB 01h                 ;reserved/descriptor code (this maximum unformatted memory)
       DB 00h,02h,00h         ;block length (512 bytes/sector)
capacityData:
       DB 00h,00h,0Fh,0FFh    ;last logical block address
       DB 00h,00h,02h,00h     ;block length (512 bytes/sector)
modeSense1C:
       DB 12h,00h,00h,00h,00h,00h,00h,1Ch
modeSense1CEnd:
modeSense3F:
       DB 43h,00h,00h,00h,01h,0Ah,00h,03h,00h,00h, 00h,00h,80h,03h,00h,00h
       DB 05h,1Eh,13h,88h,00h,08h,20h,00h,00h,03h,0D8h,00h,00h,00h,00h,00h
       DB 00h,00h,00h,05h,1Eh,00h,00h,00h,00h,00h, 00h,00h,01h,68h,00h,00h
       DB 1Bh,0Ah,00h,01h,00h,00h,00h,00h,00h,00h, 00h,00h,1Ch,06h,00h,05h
       DB 00h,00h,00h,1Ch
modeSense3FEnd:

